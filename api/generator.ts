// Helper script to generate the framer.data.json file that is then consumed by
// the FramerAPIContext component. The JSON file should extract as much useful
// information from the api-extractor AST and it's nested TSDoc AST to avoid
// having to do all this processing in the React components.
//
// The script takes a list of inputs - api.json files generated by api-extractor
// and will output a processed JSON file to stdout.
//
// Usage:
//   % ./api/generator.ts <input> [...<input2>]
//
// References:
// https://github.com/Microsoft/web-build-tools/blob/master/apps/api-documenter/src/documenters/MarkdownDocumenter.ts
// https://microsoft.github.io/web-build-tools/api/api-extractor.html
//
// To Do:
// - [ ] Support an optional --out flag to specify an output file.
import * as fs from "fs"
import * as path from "path"
import * as assert from "assert"
import { AedocDefinitions, ApiModel, ReleaseTag as ApiReleaseTag } from "@microsoft/api-extractor-model"
import { TSDocConfiguration, TSDocTagDefinition, TSDocTagSyntaxKind, StandardTags } from "@microsoft/tsdoc"
import { walk } from "./walker"
import { RawAPIData, Kind, AnyRawModel } from "./types"

const configuration: TSDocConfiguration = new TSDocConfiguration()

const production = new TSDocTagDefinition({
    tagName: "@production",
    syntaxKind: TSDocTagSyntaxKind.BlockTag,
    allowMultiple: false,
})

const prototype = new TSDocTagDefinition({
    tagName: "@prototype",
    syntaxKind: TSDocTagSyntaxKind.BlockTag,
    allowMultiple: false,
})

configuration.addTagDefinitions(
    [
        AedocDefinitions.betaDocumentation,
        AedocDefinitions.internalRemarks,
        AedocDefinitions.preapprovedTag,
        production,
        prototype,
    ],
    true
)

configuration.setSupportForTags(
    [
        StandardTags.alpha,
        StandardTags.beta,
        StandardTags.defaultValue,
        StandardTags.deprecated,
        StandardTags.eventProperty,
        StandardTags.example,
        StandardTags.inheritDoc,
        StandardTags.internal,
        StandardTags.link,
        StandardTags.override,
        StandardTags.packageDocumentation,
        StandardTags.param,
        StandardTags.privateRemarks,
        StandardTags.public,
        StandardTags.readonly,
        StandardTags.remarks,
        StandardTags.returns,
        StandardTags.sealed,
        StandardTags.virtual,
        production,
        prototype,
    ],
    true
)

Object.defineProperty(AedocDefinitions.prototype, "_tsdocConfiguration", configuration)
//AedocDefinitions.prototype._tsdocConfiguration = configuration

function usage() {
    console.log(`Usage:\n    ${path.basename(process.argv[1])} <input1>[, <input2>]\n`)
    console.log(
        `Example:\n    ${path.basename(
            process.argv[1]
        )} ../FramerStudio/Source/Library/build/framer.api.json api/framer.data.json\n`
    )
}

if (process.argv.length <= 2) {
    usage()
    process.exit()
}

function processInput(filepath: string): RawAPIData {
    if (!fs.existsSync(filepath)) {
        console.error(`Unable to read input file: ${filepath}`)
        process.exit(1)
    }

    const pkg = new ApiModel().loadPackage(filepath)
    assert.equal(pkg.entryPoints.length, 1, "Only support a single entry point at the moment")

    const map: RawAPIData = {}

    walk(pkg.entryPoints[0], ApiReleaseTag.Beta, item => {
        type PartialRawAPIData = { [key: string]: { model?: AnyRawModel; children: PartialRawAPIData } }
        const keys = item.id.split(".")

        // Holds the current map of key -> child
        let current: PartialRawAPIData = map
        while (keys.length) {
            const key = keys.shift()!

            if (!current[key]) {
                current[key] = { children: {} }
            }

            if (keys.length === 0) {
                // Warn if we encounter duplicate fields exported by seperate packages
                // we can ignore params though as these will regularly crop up due to
                // overloads.
                // TODO: We could include the package name with the namespace.
                if (current[key].model && item.kind !== Kind.Parameter) {
                    process.stderr.write(`Skipping duplicate entry for "${item.id}"\n`)
                } else {
                    current[key].model = item
                }
            }

            current = current[key].children
        }
    })

    return map
}

let map: RawAPIData = {}
for (const filepath of process.argv.slice(2)) {
    map = { ...map, ...processInput(filepath) }
}

const data = JSON.stringify(map, null, "  ") + "\n"
process.stdout.write(data)
