<!-- ðŸ‘‹ Editing this file? Need help? â†’ https://github.com/framer/api-docs/blob/master/CONTRIBUTING.md -->

import {
  APIClass,
  APIVariable,
  APIFunction,
  APIMethod,
  APIInterface,
  APIProperty,
  APIMergedInterface,
  Template,
  Link,
  Ref,
  Callout,
  Todo,
  Button,
  EmbeddedExample,
} from "../../components"
import { AnimatePresenceExample } from "../../components/examples/motion"

export default Template("AnimateSharedLayout")

# AnimateSharedLayout

<span className="lead">
  Animate layout changes across, and between, multiple
  components.
</span>

<div>

The `AnimateSharedLayout` component enables you to perform <Link href="/pages/motion/animation/#layout-animations">layout animations</Link>:

- Across a set of components that don't otherwise share state
- Between different components that share a `layoutId` as they're added/removed.

</div>

```jsx
import { AnimateSharedLayout } from "framer-motion"
```

---

## Syncing layout animations

`motion` components with a `layout` prop will automatically <Link href="/pages/motion/animation/#layout-animations">animate layout changes</Link> that occur when they re-render.

```jsx
<motion.div layout />
```

However, if a `layout` component changes layout due to local state change, surrounding components need a way to know they should animate their layout, too.

```jsx
function Item({ content }) {
  const [isOpen, setIsOpen] = useState(false)

  return <motion.div layout>{isOpen && content}</motion.div>
}

function List({ items }) {
  /**
   * This wrapping motion.ul, and sibling
   * Item components won't animate layout
   * when an Item opens/closes
   */
  return (
    <motion.ul layout>
      {items.map(item => (
        <Item content={item.content} />
      ))}
    </motion.ul>
  )
}
```

By wrapping components with `AnimateSharedLayout`, all `layout` components within will inform each other when their layout changes, and animate accordingly.

```jsx
function List({ items, selectedId }) {
  return (
    <AnimateSharedLayout>
      <motion.ul layout>
        {items.map(item => (
          <Item content={item.content} />
        ))}
      </motion.ul>
    </AnimateSharedLayout>
  )
}
```

**Add example**

## Animate between components

`AnimateSharedLayout` can be used to animate between completely different `motion` components that share the same `layoutId` prop.

<div>

In this example, each item contains a `motion` component with a `layoutId="underline"` prop that gets rendered only if the item is selected.

<iframe
  src="https://codesandbox.io/embed/framer-motion-magic-motion-underline-menu-demo-y6tl3?fontsize=14&hidenavigation=1&hidedevtools=1&theme=dark"
  style={{
    width: "100%",
    height: "500px",
    border: 0,
    borderRadius: 4,
    overflow: "hidden",
    marginBottom: 40,
  }}
  title="Framer Motion: Magic Motion underline menu demo"
  allow="geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb"
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
></iframe>

</div>

```jsx
isSelected && <motion.div layoutId="underline" />
```

When a new component with a `layoutId` gets added as another gets removed, the component will perform a <Link href="/pages/motion/animation/#layout-animations">layout animation</Link> from previous component.

The new component will also any animating values from the old component as its `initial` state. So visually it'll be treated as one continuous component.

```jsx
<motion.div
  layoutId="underline"
  initial={false}
  animate={{ backgroundColor: "#ff0000" }}
/>
```

**Note:** If the previous component remains in the tree, it'll automatically be hidden using `visibility: hidden`. If the new component is subsequently removed, the previous component will be set back to visible.

## Experimental

<Callout>
  The following features are considered{" "}
  <strong>experimental</strong>. Their API is stable, but
  due to the number of implementation permutations it's
  possible we haven't caught every bug or addressed every
  use-case. If you run into bugs or unexpected behaviours,
  please{" "}
  <a href="https://github.com/framer/motion/issues">
    open an issue
  </a>
  .
</Callout>

### Shared drag session

<div>

A `motion` component can be provided both a `drag` and a `layoutId` prop.

If a component is currently being dragged when it's removed, and a new component with the same `layoutId` is added elsewhere, rather than perform a layout animation, the drag gesture will continue on the new component.

</div>

```jsx
<motion.div drag layoutId="box" />
```

In a future release, the component will perform a layout animation to its new size.

**Add example**

### AnimatePresence

<div>

When a `layoutId` component is added, and an existing component with that same `layoutId` remains, the older component will automatically be hidden. The new component will animate out from its position.

By wrapping the new component in `AnimatePresence`, when its removed from the tree it'll automatically animate back to the original component's position.

</div>

```jsx
<AnimateSharedLayout>
  {images.map((img) => <motion.img layoutId={img.id} />)}
  <AnimatePresence>
    {selectedId && <motion.img layoutId={selectedId} />)}
  </AnimatePresence>
</AnimateSharedLayout>
```

**Add example**

### Crossfade

Two components with the same `layoutId` might look quite different to each other. For instance, a text box might have different line wrapping in one layout than the other.

```jsx
<AnimateSharedLayout type="crossfade">
  {images.map((img) => <motion.img layoutId={img.id} />)}
  <AnimatePresence>
    {selectedId && <motion.img layoutId={selectedId} />)}
  </AnimatePresence>
</AnimateSharedLayout>
```

**Add example**
